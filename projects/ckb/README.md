# CKB

This folder keeps reproducible build designs for [Nervos CKB](https://github.com/nervosnetwork/ckb).

We started this path following [Bitcoin's reproducible build setup](https://github.com/bitcoin/bitcoin/tree/689a32197638e92995dd8eb071425715f5fdc3a4/contrib/guix) using [Guix](https://guix.gnu.org/). We spent a huge amount of time tweaking Guix for our purposes. We do want to mention that reproducible build for Bitcoin is slightly simpler, since Bitcoin just relies on a C++ compiler. CKB is a hybrid codebase that uses Rust, C / C++ and slight assembly code. It is extremely hard to build a complete reproducible build workflow for CKB, using Guix.

On the other hand, buried deep down in Guix is still a [small part](https://guix.gnu.org/en/blog/2023/the-full-source-bootstrap-building-from-source-all-the-way-down/) one needs to *trust* for full bootstrapping. The guix team have done tremendous job to minimize this binary part one needs to trust, however, this part still remains in the stack.

Now the question really is: can we do better than this?

Binary blobs will always be inevitable, no matter what workflow is employed. Instead of avoiding binary blobs, what if we can have different sources of binary blobs? Given different OSes, if they can all reproducibly build the same CKB binary from the same source code, we will have a higher confidence that our reproducible build workflow is valid, even in the presence of binary blobs.

Hence we picked a different reproducible build & bootstrapping workflow compared to Bitcoin. Specifically, CKB shall be reproducibly built from one of the following different methods:

## Crosstool-ng

Starting from crosstool-ng, the first reproducible bootstrapping design works like this:

1. Install crosstool-ng from source, binary blobs on current native OS will be used;
2. Use crosstool-ng to build a GNU toolchain with a specific version of gcc and glibc(gcc 8.5.0 and glibc 2.27 for now);
3. Build LLVM / clang using the above built GNU toolchain.
4. Build Rust with the above built LLVM / clang and GNU toolchain. We will only use clang as the C / C++ compiler, GNU toolchain simply provides sysroot
5. Build CKB with Rust and clang.

We have implemented the above steps on `Ubuntu 24.04`, `Debian 13`, `Fedora 42` and latest `Archlinux`, they all generate the same CKB binary reproducibly.

## NixOS (WIP)

We plan to levarage nix's own build system to build GNU toolchain, LLVM / clang and Rust, then build the CKB binary. The goal here is that the same binary as the above `crosstool-ng` path should be generated by nix workflow.

## Guix (Theoretically possible)

In theory we can still tweak guix to achieve the same steps, resulting in the same binary. But I was not familiar enough with Guix for this task. We will simply leave it till another time.
